/* Clock.c generated by valac 0.42.5, the Vala compiler
 * generated from Clock.vala, do not modify */

/*
* Copyright (c) 2011-2020 NotificationCenter
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License as published by the Free Software Foundation; either
* version 2 of the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
*
* You should have received a copy of the GNU General Public
* License along with this program; if not, write to the
* Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
* Boston, MA 02110-1301 USA
*
* Authored by: Kris Henriksen <krishenriksen.work@gmail.com>
*/

#define _XOPEN_SOURCE

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <time.h>
#include <cairo.h>
#include <gdk/gdk.h>
#include <float.h>
#include <math.h>


#define NOTIFICATION_CENTER_TYPE_CLOCK_WIDGET (notification_center_clock_widget_get_type ())
#define NOTIFICATION_CENTER_CLOCK_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), NOTIFICATION_CENTER_TYPE_CLOCK_WIDGET, NotificationCenterClockWidget))
#define NOTIFICATION_CENTER_CLOCK_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), NOTIFICATION_CENTER_TYPE_CLOCK_WIDGET, NotificationCenterClockWidgetClass))
#define NOTIFICATION_CENTER_IS_CLOCK_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NOTIFICATION_CENTER_TYPE_CLOCK_WIDGET))
#define NOTIFICATION_CENTER_IS_CLOCK_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), NOTIFICATION_CENTER_TYPE_CLOCK_WIDGET))
#define NOTIFICATION_CENTER_CLOCK_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), NOTIFICATION_CENTER_TYPE_CLOCK_WIDGET, NotificationCenterClockWidgetClass))

typedef struct _NotificationCenterClockWidget NotificationCenterClockWidget;
typedef struct _NotificationCenterClockWidgetClass NotificationCenterClockWidgetClass;
typedef struct _NotificationCenterClockWidgetPrivate NotificationCenterClockWidgetPrivate;
enum  {
	NOTIFICATION_CENTER_CLOCK_WIDGET_0_PROPERTY,
	NOTIFICATION_CENTER_CLOCK_WIDGET_NUM_PROPERTIES
};
static GParamSpec* notification_center_clock_widget_properties[NOTIFICATION_CENTER_CLOCK_WIDGET_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _cairo_region_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_region_destroy (var), NULL)))
enum  {
	NOTIFICATION_CENTER_CLOCK_WIDGET_TIME_CHANGED_SIGNAL,
	NOTIFICATION_CENTER_CLOCK_WIDGET_NUM_SIGNALS
};
static guint notification_center_clock_widget_signals[NOTIFICATION_CENTER_CLOCK_WIDGET_NUM_SIGNALS] = {0};

struct _NotificationCenterClockWidget {
	GtkDrawingArea parent_instance;
	NotificationCenterClockWidgetPrivate * priv;
};

struct _NotificationCenterClockWidgetClass {
	GtkDrawingAreaClass parent_class;
};

struct _NotificationCenterClockWidgetPrivate {
	struct tm time;
	gint minute_offset;
	gboolean dragging;
};


static gint NotificationCenterClockWidget_private_offset;
static gpointer notification_center_clock_widget_parent_class = NULL;

GType notification_center_clock_widget_get_type (void) G_GNUC_CONST;
NotificationCenterClockWidget* notification_center_clock_widget_new (void);
NotificationCenterClockWidget* notification_center_clock_widget_construct (GType object_type);
static gboolean notification_center_clock_widget_update (NotificationCenterClockWidget* self);
static gboolean _notification_center_clock_widget_update_gsource_func (gpointer self);
static gboolean notification_center_clock_widget_real_draw (GtkWidget* base,
                                                     cairo_t* cr);
static gboolean notification_center_clock_widget_real_button_press_event (GtkWidget* base,
                                                                   GdkEventButton* event);
static gboolean notification_center_clock_widget_real_button_release_event (GtkWidget* base,
                                                                     GdkEventButton* event);
static void notification_center_clock_widget_emit_time_changed_signal (NotificationCenterClockWidget* self,
                                                                gint x,
                                                                gint y);
static gboolean notification_center_clock_widget_real_motion_notify_event (GtkWidget* base,
                                                                    GdkEventMotion* event);
static void notification_center_clock_widget_redraw_canvas (NotificationCenterClockWidget* self);
static void g_cclosure_user_marshal_VOID__INT_INT (GClosure * closure,
                                            GValue * return_value,
                                            guint n_param_values,
                                            const GValue * param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);
static void notification_center_clock_widget_finalize (GObject * obj);


static inline gpointer
notification_center_clock_widget_get_instance_private (NotificationCenterClockWidget* self)
{
	return G_STRUCT_MEMBER_P (self, NotificationCenterClockWidget_private_offset);
}


static gboolean
_notification_center_clock_widget_update_gsource_func (gpointer self)
{
	gboolean result;
	result = notification_center_clock_widget_update ((NotificationCenterClockWidget*) self);
	return result;
}


NotificationCenterClockWidget*
notification_center_clock_widget_construct (GType object_type)
{
	NotificationCenterClockWidget * self = NULL;
	self = (NotificationCenterClockWidget*) g_object_new (object_type, NULL);
	gtk_widget_add_events ((GtkWidget*) self, (gint) ((GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK) | GDK_POINTER_MOTION_MASK));
	notification_center_clock_widget_update (self);
	gtk_widget_set_size_request ((GtkWidget*) self, 80, 80);
	g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 1000, _notification_center_clock_widget_update_gsource_func, g_object_ref (self), g_object_unref);
	return self;
}


NotificationCenterClockWidget*
notification_center_clock_widget_new (void)
{
	return notification_center_clock_widget_construct (NOTIFICATION_CENTER_TYPE_CLOCK_WIDGET);
}


static gboolean
notification_center_clock_widget_real_draw (GtkWidget* base,
                                            cairo_t* cr)
{
	NotificationCenterClockWidget * self;
	gboolean result = FALSE;
	gint x = 0;
	gint y = 0;
	gdouble radius = 0.0;
	gint _tmp0_;
	gint _tmp1_;
	gdouble _tmp2_;
	gint hours = 0;
	struct tm _tmp23_;
	gint _tmp24_;
	gint minutes = 0;
	struct tm _tmp25_;
	gint _tmp26_;
	gint _tmp27_;
	gint seconds = 0;
	struct tm _tmp28_;
	gint _tmp29_;
	gint _tmp30_;
	gint _tmp31_;
	gint _tmp32_;
	gdouble _tmp33_;
	gint _tmp34_;
	gdouble _tmp35_;
	gint _tmp36_;
	gint _tmp37_;
	gint _tmp38_;
	gdouble _tmp39_;
	gint _tmp40_;
	gdouble _tmp41_;
	gint _tmp42_;
	gint _tmp43_;
	gint _tmp44_;
	gdouble _tmp45_;
	gint _tmp46_;
	gdouble _tmp47_;
	self = (NotificationCenterClockWidget*) base;
	g_return_val_if_fail (cr != NULL, FALSE);
	x = gtk_widget_get_allocated_width ((GtkWidget*) self) / 2;
	y = gtk_widget_get_allocated_height ((GtkWidget*) self) / 2;
	radius = MIN ((gdouble) (gtk_widget_get_allocated_width ((GtkWidget*) self) / 2), (gdouble) (gtk_widget_get_allocated_height ((GtkWidget*) self) / 2)) - 5;
	_tmp0_ = x;
	_tmp1_ = y;
	_tmp2_ = radius;
	cairo_arc (cr, (gdouble) _tmp0_, (gdouble) _tmp1_, _tmp2_, (gdouble) 0, 2 * G_PI);
	cairo_set_source_rgb (cr, (gdouble) 1, (gdouble) 1, (gdouble) 1);
	cairo_fill_preserve (cr);
	cairo_set_source_rgb (cr, (gdouble) 0, (gdouble) 0, (gdouble) 0);
	cairo_stroke (cr);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gint _tmp5_;
				gint inset = 0;
				gint _tmp6_;
				gint _tmp9_;
				gdouble _tmp10_;
				gint _tmp11_;
				gint _tmp12_;
				gint _tmp13_;
				gdouble _tmp14_;
				gint _tmp15_;
				gint _tmp16_;
				gint _tmp17_;
				gdouble _tmp18_;
				gint _tmp19_;
				gint _tmp20_;
				gdouble _tmp21_;
				gint _tmp22_;
				if (!_tmp3_) {
					gint _tmp4_;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp5_ = i;
				if (!(_tmp5_ < 12)) {
					break;
				}
				cairo_save (cr);
				_tmp6_ = i;
				if ((_tmp6_ % 3) == 0) {
					gdouble _tmp7_;
					_tmp7_ = radius;
					inset = (gint) (0.2 * _tmp7_);
				} else {
					gdouble _tmp8_;
					_tmp8_ = radius;
					inset = (gint) (0.1 * _tmp8_);
					cairo_set_line_width (cr, 0.5 * cairo_get_line_width (cr));
				}
				_tmp9_ = x;
				_tmp10_ = radius;
				_tmp11_ = inset;
				_tmp12_ = i;
				_tmp13_ = y;
				_tmp14_ = radius;
				_tmp15_ = inset;
				_tmp16_ = i;
				cairo_move_to (cr, _tmp9_ + ((_tmp10_ - _tmp11_) * cos ((_tmp12_ * G_PI) / 6)), _tmp13_ + ((_tmp14_ - _tmp15_) * sin ((_tmp16_ * G_PI) / 6)));
				_tmp17_ = x;
				_tmp18_ = radius;
				_tmp19_ = i;
				_tmp20_ = y;
				_tmp21_ = radius;
				_tmp22_ = i;
				cairo_line_to (cr, _tmp17_ + (_tmp18_ * cos ((_tmp19_ * G_PI) / 6)), _tmp20_ + (_tmp21_ * sin ((_tmp22_ * G_PI) / 6)));
				cairo_stroke (cr);
				cairo_restore (cr);
			}
		}
	}
	_tmp23_ = self->priv->time;
	_tmp24_ = _tmp23_.tm_hour;
	hours = _tmp24_;
	_tmp25_ = self->priv->time;
	_tmp26_ = _tmp25_.tm_min;
	_tmp27_ = self->priv->minute_offset;
	minutes = _tmp26_ + _tmp27_;
	_tmp28_ = self->priv->time;
	_tmp29_ = _tmp28_.tm_sec;
	seconds = _tmp29_;
	cairo_save (cr);
	cairo_set_line_width (cr, 2.5 * cairo_get_line_width (cr));
	_tmp30_ = x;
	_tmp31_ = y;
	cairo_move_to (cr, (gdouble) _tmp30_, (gdouble) _tmp31_);
	_tmp32_ = x;
	_tmp33_ = radius;
	_tmp34_ = y;
	_tmp35_ = radius;
	cairo_line_to (cr, _tmp32_ + ((_tmp33_ / 2) * sin (((G_PI / 6) * hours) + ((G_PI / 360) * minutes))), _tmp34_ + ((_tmp35_ / 2) * (-cos (((G_PI / 6) * hours) + ((G_PI / 360) * minutes)))));
	cairo_stroke (cr);
	cairo_restore (cr);
	_tmp36_ = x;
	_tmp37_ = y;
	cairo_move_to (cr, (gdouble) _tmp36_, (gdouble) _tmp37_);
	_tmp38_ = x;
	_tmp39_ = radius;
	_tmp40_ = y;
	_tmp41_ = radius;
	cairo_line_to (cr, _tmp38_ + ((_tmp39_ * 0.75) * sin ((G_PI / 30) * minutes)), _tmp40_ + ((_tmp41_ * 0.75) * (-cos ((G_PI / 30) * minutes))));
	cairo_stroke (cr);
	cairo_save (cr);
	cairo_set_source_rgb (cr, (gdouble) 1, (gdouble) 0, (gdouble) 0);
	_tmp42_ = x;
	_tmp43_ = y;
	cairo_move_to (cr, (gdouble) _tmp42_, (gdouble) _tmp43_);
	_tmp44_ = x;
	_tmp45_ = radius;
	_tmp46_ = y;
	_tmp47_ = radius;
	cairo_line_to (cr, _tmp44_ + ((_tmp45_ * 0.7) * sin ((G_PI / 30) * seconds)), _tmp46_ + ((_tmp47_ * 0.7) * (-cos ((G_PI / 30) * seconds))));
	cairo_stroke (cr);
	cairo_restore (cr);
	result = FALSE;
	return result;
}


static gboolean
notification_center_clock_widget_real_button_press_event (GtkWidget* base,
                                                          GdkEventButton* event)
{
	NotificationCenterClockWidget * self;
	gboolean result = FALSE;
	gint minutes = 0;
	struct tm _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gdouble px = 0.0;
	gdouble _tmp3_;
	gdouble py = 0.0;
	gdouble _tmp4_;
	gdouble lx = 0.0;
	gint _tmp5_;
	gdouble ly = 0.0;
	gint _tmp6_;
	gdouble u = 0.0;
	gdouble _tmp7_;
	gdouble _tmp8_;
	gdouble _tmp9_;
	gdouble _tmp10_;
	gdouble _tmp11_;
	gdouble d2 = 0.0;
	gdouble _tmp12_;
	gdouble _tmp13_;
	gdouble _tmp14_;
	gdouble _tmp15_;
	gdouble _tmp16_;
	gdouble _tmp17_;
	gdouble _tmp18_;
	self = (NotificationCenterClockWidget*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = self->priv->time;
	_tmp1_ = _tmp0_.tm_min;
	_tmp2_ = self->priv->minute_offset;
	minutes = _tmp1_ + _tmp2_;
	_tmp3_ = event->x;
	px = _tmp3_ - (gtk_widget_get_allocated_width ((GtkWidget*) self) / 2);
	_tmp4_ = event->y;
	py = (gtk_widget_get_allocated_height ((GtkWidget*) self) / 2) - _tmp4_;
	_tmp5_ = minutes;
	lx = sin ((G_PI / 30) * _tmp5_);
	_tmp6_ = minutes;
	ly = cos ((G_PI / 30) * _tmp6_);
	_tmp7_ = lx;
	_tmp8_ = px;
	_tmp9_ = ly;
	_tmp10_ = py;
	u = (_tmp7_ * _tmp8_) + (_tmp9_ * _tmp10_);
	_tmp11_ = u;
	if (_tmp11_ < ((gdouble) 0)) {
		result = FALSE;
		return result;
	}
	_tmp12_ = px;
	_tmp13_ = u;
	_tmp14_ = lx;
	_tmp15_ = py;
	_tmp16_ = u;
	_tmp17_ = ly;
	d2 = pow (_tmp12_ - (_tmp13_ * _tmp14_), (gdouble) 2) + pow (_tmp15_ - (_tmp16_ * _tmp17_), (gdouble) 2);
	_tmp18_ = d2;
	if (_tmp18_ < ((gdouble) 25)) {
		self->priv->dragging = TRUE;
		g_print ("got minute hand\n");
	}
	result = FALSE;
	return result;
}


static gboolean
notification_center_clock_widget_real_button_release_event (GtkWidget* base,
                                                            GdkEventButton* event)
{
	NotificationCenterClockWidget * self;
	gboolean result = FALSE;
	gboolean _tmp0_;
	self = (NotificationCenterClockWidget*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = self->priv->dragging;
	if (_tmp0_) {
		gdouble _tmp1_;
		gdouble _tmp2_;
		self->priv->dragging = FALSE;
		_tmp1_ = event->x;
		_tmp2_ = event->y;
		notification_center_clock_widget_emit_time_changed_signal (self, (gint) _tmp1_, (gint) _tmp2_);
	}
	result = FALSE;
	return result;
}


static gboolean
notification_center_clock_widget_real_motion_notify_event (GtkWidget* base,
                                                           GdkEventMotion* event)
{
	NotificationCenterClockWidget * self;
	gboolean result = FALSE;
	gboolean _tmp0_;
	self = (NotificationCenterClockWidget*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = self->priv->dragging;
	if (_tmp0_) {
		gdouble _tmp1_;
		gdouble _tmp2_;
		_tmp1_ = event->x;
		_tmp2_ = event->y;
		notification_center_clock_widget_emit_time_changed_signal (self, (gint) _tmp1_, (gint) _tmp2_);
	}
	result = FALSE;
	return result;
}


static void
notification_center_clock_widget_emit_time_changed_signal (NotificationCenterClockWidget* self,
                                                           gint x,
                                                           gint y)
{
	gdouble phi = 0.0;
	gdouble _tmp0_;
	gint hour = 0;
	struct tm _tmp2_;
	gint _tmp3_;
	gint minute = 0;
	gdouble _tmp4_;
	struct tm _tmp5_;
	gint _tmp6_;
	g_return_if_fail (self != NULL);
	x = x - (gtk_widget_get_allocated_width ((GtkWidget*) self) / 2);
	y = y - (gtk_widget_get_allocated_height ((GtkWidget*) self) / 2);
	phi = atan2 ((gdouble) x, (gdouble) (-y));
	_tmp0_ = phi;
	if (_tmp0_ < ((gdouble) 0)) {
		gdouble _tmp1_;
		_tmp1_ = phi;
		phi = _tmp1_ + (G_PI * 2);
	}
	_tmp2_ = self->priv->time;
	_tmp3_ = _tmp2_.tm_hour;
	hour = _tmp3_;
	_tmp4_ = phi;
	minute = (gint) ((_tmp4_ * 30) / G_PI);
	_tmp5_ = self->priv->time;
	_tmp6_ = _tmp5_.tm_min;
	self->priv->minute_offset = minute - _tmp6_;
	notification_center_clock_widget_redraw_canvas (self);
	g_signal_emit (self, notification_center_clock_widget_signals[NOTIFICATION_CENTER_CLOCK_WIDGET_TIME_CHANGED_SIGNAL], 0, hour, minute);
}


static void
g_time_local (time_t time,
              struct tm* result)
{
	struct tm _result_ = {0};
	struct tm _tmp0_ = {0};
	localtime_r (&time, &_tmp0_);
	_result_ = _tmp0_;
	*result = _result_;
	return;
}


static gboolean
notification_center_clock_widget_update (NotificationCenterClockWidget* self)
{
	gboolean result = FALSE;
	time_t _tmp0_;
	struct tm _tmp1_ = {0};
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = time (NULL);
	g_time_local (_tmp0_, &_tmp1_);
	self->priv->time = _tmp1_;
	notification_center_clock_widget_redraw_canvas (self);
	result = TRUE;
	return result;
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


static void
notification_center_clock_widget_redraw_canvas (NotificationCenterClockWidget* self)
{
	GdkWindow* window = NULL;
	GdkWindow* _tmp0_;
	GdkWindow* _tmp1_;
	GdkWindow* _tmp2_;
	cairo_region_t* region = NULL;
	GdkWindow* _tmp3_;
	cairo_region_t* _tmp4_;
	GdkWindow* _tmp5_;
	cairo_region_t* _tmp6_;
	GdkWindow* _tmp7_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	window = _tmp1_;
	_tmp2_ = window;
	if (NULL == _tmp2_) {
		_g_object_unref0 (window);
		return;
	}
	_tmp3_ = window;
	_tmp4_ = gdk_window_get_clip_region (_tmp3_);
	region = _tmp4_;
	_tmp5_ = window;
	_tmp6_ = region;
	gdk_window_invalidate_region (_tmp5_, _tmp6_, TRUE);
	_tmp7_ = window;
	gdk_window_process_updates (_tmp7_, TRUE);
	_cairo_region_destroy0 (region);
	_g_object_unref0 (window);
}


static void
g_cclosure_user_marshal_VOID__INT_INT (GClosure * closure,
                                       GValue * return_value,
                                       guint n_param_values,
                                       const GValue * param_values,
                                       gpointer invocation_hint,
                                       gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__INT_INT) (gpointer data1, gint arg_1, gint arg_2, gpointer data2);
	register GMarshalFunc_VOID__INT_INT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__INT_INT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_int (param_values + 1), g_value_get_int (param_values + 2), data2);
}


static void
notification_center_clock_widget_class_init (NotificationCenterClockWidgetClass * klass)
{
	notification_center_clock_widget_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &NotificationCenterClockWidget_private_offset);
	((GtkWidgetClass *) klass)->draw = (gboolean (*) (GtkWidget*, cairo_t*)) notification_center_clock_widget_real_draw;
	((GtkWidgetClass *) klass)->button_press_event = (gboolean (*) (GtkWidget*, GdkEventButton*)) notification_center_clock_widget_real_button_press_event;
	((GtkWidgetClass *) klass)->button_release_event = (gboolean (*) (GtkWidget*, GdkEventButton*)) notification_center_clock_widget_real_button_release_event;
	((GtkWidgetClass *) klass)->motion_notify_event = (gboolean (*) (GtkWidget*, GdkEventMotion*)) notification_center_clock_widget_real_motion_notify_event;
	G_OBJECT_CLASS (klass)->finalize = notification_center_clock_widget_finalize;
	notification_center_clock_widget_signals[NOTIFICATION_CENTER_CLOCK_WIDGET_TIME_CHANGED_SIGNAL] = g_signal_new ("time-changed", NOTIFICATION_CENTER_TYPE_CLOCK_WIDGET, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__INT_INT, G_TYPE_NONE, 2, G_TYPE_INT, G_TYPE_INT);
}


static void
notification_center_clock_widget_instance_init (NotificationCenterClockWidget * self)
{
	self->priv = notification_center_clock_widget_get_instance_private (self);
}


static void
notification_center_clock_widget_finalize (GObject * obj)
{
	NotificationCenterClockWidget * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, NOTIFICATION_CENTER_TYPE_CLOCK_WIDGET, NotificationCenterClockWidget);
	G_OBJECT_CLASS (notification_center_clock_widget_parent_class)->finalize (obj);
}


GType
notification_center_clock_widget_get_type (void)
{
	static volatile gsize notification_center_clock_widget_type_id__volatile = 0;
	if (g_once_init_enter (&notification_center_clock_widget_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (NotificationCenterClockWidgetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) notification_center_clock_widget_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (NotificationCenterClockWidget), 0, (GInstanceInitFunc) notification_center_clock_widget_instance_init, NULL };
		GType notification_center_clock_widget_type_id;
		notification_center_clock_widget_type_id = g_type_register_static (gtk_drawing_area_get_type (), "NotificationCenterClockWidget", &g_define_type_info, 0);
		NotificationCenterClockWidget_private_offset = g_type_add_instance_private (notification_center_clock_widget_type_id, sizeof (NotificationCenterClockWidgetPrivate));
		g_once_init_leave (&notification_center_clock_widget_type_id__volatile, notification_center_clock_widget_type_id);
	}
	return notification_center_clock_widget_type_id__volatile;
}



